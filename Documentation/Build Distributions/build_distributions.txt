After doing some research, it appears that there are two primary options for building an executable.

cx_Freeze, which I believe will probably end up the better option.

PyInstaller, which looks easier, but I have less confidence that it will work.


CX_FREEZE:

distutils setup script

In order to make use of distutils a setup script must be created. This is called setup.py by convention, although it can have any name. It looks something like this:

import sys
from cx_Freeze import setup, Executable

# Dependencies are automatically detected, but it might need fine tuning.
build_exe_options = {"packages": ["os"], "excludes": ["tkinter"]}

# GUI applications require a different base on Windows (the default is for
# a console application).
base = None
if sys.platform == "win32":
    base = "Win32GUI"

setup(  name = "guifoo",
        version = "0.1",
        description = "My GUI application!",
        options = {"build_exe": build_exe_options},
        executables = [Executable("guifoo.py", base=base)])
There are more examples in the samples/ directory of the source.

The script is invoked as follows:

python setup.py build
This command will create a subdirectory called build with a further subdirectory starting with the letters exe. and ending with the typical identifier for the platform that distutils uses. This allows for multiple platforms to be built without conflicts.

On Windows, you can build a simple installer containing all the files cx_Freeze includes for your application, by running the setup script as:

python setup.py bdist_msi
On Mac OS X, you can use bdist_dmg to build a Mac disk image.

distutils commands
cx_Freeze creates four new commands and subclasses four others in order to provide the ability to both build and install executables. In typical distutils fashion they can be provided in the setup script, on the command line or in a setup.cfg configuration file. They are described in further detail below.

To specify options in the script, use underscores in the name. For example:

setup(...
      options = {'build_exe': {'init_script':'Console'}} )
To specify the same options on the command line, use dashes, like this:

python setup.py build_exe --init-script Console
Some options also have a short form to use on the command line. These are given in brackets below.

build
This command is a standard command which has been modified by cx_Freeze to build any executables that are defined. The following options were added to the standard set of options for the command:

option name	description
build_exe (-b)	directory for built executables and dependent files, defaults to a directory of the form build/exe.[platform identifier].[python version]
build_exe
This command performs the work of building an executable or set of executables. It can be further customized:

option name	description
build_exe (-b)	directory for built executables and dependent files, defaults to the value of the “build_exe” option on the build command (see above); note that using this option (instead of the corresponding option on the build command) may break bdist_msi, bdist_mac, and other commands
optimize (-o)	optimization level, one of 0 (disabled), 1 or 2
excludes (-e)	comma separated list of names of modules to exclude
includes (-e)	comma separated list of names of modules to include
packages (-p)	comma separated list of packages to include, which includes all submodules in the package
replace_paths	Modify filenames attached to code objects, which appear in tracebacks. Pass a comma separated list of paths in the form <search>=<replace>. The value * in the search portion will match the directory containing the entire package, leaving just the relative path to the module.
path	comma separated list of paths to search; the default value is sys.path
no_compress	create a zipfile with no compression
constants	comma separated list of constant values to include in the constants module called BUILD_CONSTANTS in the form <name>=<value>
include_files	list containing files to be copied to the target directory; it is expected that this list will contain strings or 2-tuples for the source and destination; the source can be a file or a directory (in which case the tree is copied except for .svn and CVS directories); the target must not be an absolute path
include_msvcr	include the Microsoft Visual C runtime DLLs without needing the redistributable package installed
zip_includes	list containing files to be included in the zip file directory; it is expected that this list will contain strings or 2-tuples for the source and destination
bin_includes	list of names of files to include when determining dependencies of binary files that would normally be excluded; note that version numbers that normally follow the shared object extension are stripped prior to performing the comparison
bin_excludes	list of names of files to exclude when determining dependencies of binary files that would normally be included; note that version numbers that normally follow the shared object extension are stripped prior to performing the comparison
bin_path_includes	list of paths from which to include files when determining dependencies of binary files
bin_path_excludes	list of paths from which to exclude files when determining dependencies of binary files
zip_include_packages	list of packages which should be included in the zip file; the default is for all packages to be placed in the file system, not the zip file; those packages which are known to work well inside a zip file can be included if desired; use * to specify that all packages should be included in the zip file
zip_exclude_packages	list of packages which should be excluded from the zip file and placed in the file system instead; the default is for all packages to be placed in the file system since a number of packages assume that is where they are found and will fail when placed in a zip file; use * to specify that all packages should be placed in the file system and excluded from the zip file (the default)
silent (-s)	suppress all output except warnings
install
This command is a standard command which has been modified by cx_Freeze to install any executables that are defined. The following options were added to the standard set of options for the command:

option name	description
install_exe	directory for installed executables and dependent files
install_exe
This command performs the work installing an executable or set of executables. It can be used directly but most often is used when building Windows installers or RPM packages. It can be further customized:

option name	description
install_dir (-d)	directory to install executables to; this defaults to a subdirectory called <name>-<version> in the “Program Files” directory on Windows and <prefix>/lib on other platforms; on platforms other than Windows symbolic links are also created in <prefix>/bin for each executable.
build_dir (-b)	build directory (where to install from); this defaults to the build_dir from the build command
force (-f)	force installation, overwriting existing files
skip_build	skip the build steps
bdist_msi
This command is a standard command in Python 2.5 and higher which has been modified by cx_Freeze to handle installing executables and their dependencies. The following options were added to the standard set of options for the command:

option_name	description
add_to_path	add the target directory to the PATH environment variable; the default value is True if there are any console based executables and False otherwise
all_users	perform installation for all users; the default value is False and results in an installation for just the installing user
data	dictionary of arbitrary MSI data indexed by table name; for each table, a list of tuples should be provided, representing the rows that should be added to the table
summary_data	dictionary of data to include in MSI summary information stream (allowable keys are “author”, “comments”, “keywords”)
directories	list of directories that should be created during installation
environment_variables	list of environment variables that should be added to the system during installation
initial_target_dir	defines the initial target directory supplied to the user during installation
install_icon	path of icon to use for the add/remove programs window that pops up during installation
product_code	define the product code for the package that is created
target_name	specifies the name of the file that is to be created
upgrade_code	define the GUID of the upgrade code for the package that is created; this is used to force removal of any packages created with the same upgrade code prior to the installation of this one; the valid format for a GUID is {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX} where X is a hex digit. Refer to Windows GUID.
For example:

'bdist_msi': {
    'upgrade_code': "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}",
    'add_to_path': True,
    'environment_variables': [
        ("E_MYAPP_VAR", "=-*MYAPP_VAR", "1", "TARGETDIR")
    ]
}
bdist_rpm
This command is a standard command which has been modified by cx_Freeze to ensure that packages are created with the proper architecture for the platform. The standard command assumes that the package should be architecture independent if it cannot find any extension modules.

bdist_mac
This command is available on Mac OS X systems, to create a Mac application bundle (a .app directory).

option_name	description
iconfile	Path to an icns icon file for the application. This will be copied into the bundle.
qt_menu_nib	Path to the qt-menu.nib file for Qt applications. By default, it will be auto-detected.
bundle_name	File name for the bundle application without the .app extension.
plist_items	A list of key-value pairs (type: List[Tuple[str, str]]) to be added to the app bundle Info.plist file.
custom_info_plist	File to be used as the Info.plist in the app bundle. A basic one will be generated by default.
include_frameworks	A list of Framework directories to include in the app bundle.
include_resources	A list of tuples of additional files to include in the app bundle’s resources directory, with the first element being the source, and second the destination file or directory name.
codesign_identity	The identity of the key to be used to sign the app bundle.
codesign_entitlements	The path to an entitlements file to use for your application’s code signature.
codesign_deep	Boolean for whether to codesign using the –deep option.
codesign_resource_rules	Plist file to be passed to codesign’s –resource-rules option.
absolute_reference_path	Path to use for all referenced libraries instead of @executable_path
rpath_lib_folder	DEPRECATED. Will be removed in next version. (Formerly replaced @rpath with given folder for any files.)
New in version 4.3.

Changed in version 4.3.2: Added the iconfile and bundle_name options.

Changed in version 4.3.3: Added the include_frameworks, custom_info_plist, codesign_identity and codesign_entitlements options.

Changed in version 4.3.4: Added the codesign_deep and codesign_resource_rules options.

Changed in version 6.0: Added the environment_variables, include_resources, absolute_reference_path and rpath_lib_folder options. Replaced the compressed option with the no_compress option.

Changed in version 6.5: Deprecated the rpath_lib_folder option.

bdist_dmg
This command is available on Mac OS X systems; it creates an application bundle, then packages it into a DMG disk image suitable for distribution and installation.

option_name	description
volume_label	Volume label of the DMG disk image
applications_shortcut	Boolean for whether to include shortcut to Applications in the DMG disk image
New in version 4.3.

Changed in version 4.3.2: Added the applications_shortcut option.

cx_Freeze.Executable
The options for the build_exe command are the defaults for any executables that are created. The options for the Executable class allow specification of the values specific to a particular executable. The arguments to the constructor are as follows:

argument name	description
script	the name of the file containing the script which is to be frozen
init_script	the name of the initialization script that will be executed before the actual script is executed; this script is used to set up the environment for the executable; if a name is given without an absolute path the names of files in the initscripts subdirectory of the cx_Freeze package is searched
base	the name of the base executable; if a name is given without an absolute path the names of files in the bases subdirectory of the cx_Freeze package is searched
target_name	the name of the target executable; the default value is the name of the script; the extension is optional (automatically added on Windows); support for names with version; if specified a pathname, raise an error.
icon	name of icon which should be included in the executable itself on Windows or placed in the target directory for other platforms (ignored in Microsoft Store Python app)
shortcut_name	the name to give a shortcut for the executable when included in an MSI package (Windows only).
shortcut_dir	the directory in which to place the shortcut when being installed by an MSI package; see the MSI Shortcut table documentation for more information on what values can be placed here (Windows only).
copyright	the copyright value to include in the version resource associated with executable (Windows only).
trademarks	the trademarks value to include in the version resource associated with the executable (Windows only).
Changed in version 6.5: Arguments are all snake_case (camelCase are still valid up to 7.0)

Note:
setup accepts a list of Executable
target_name has been extended to support version, like: target_name=”Hello-1.0” target_name=”Hello.0.1.exe”
the name of the target executable can be modified after the build only if one Executable is built.



PyInstaller

Using PyInstaller
The syntax of the pyinstaller command is:

pyinstaller [options] script [script …] | specfile
In the most simple case, set the current directory to the location of your program myscript.py and execute:

pyinstaller myscript.py
PyInstaller analyzes myscript.py and:

Writes myscript.spec in the same folder as the script.
Creates a folder build in the same folder as the script if it does not exist.
Writes some log files and working files in the build folder.
Creates a folder dist in the same folder as the script if it does not exist.
Writes the myscript executable folder in the dist folder.
In the dist folder you find the bundled app you distribute to your users.

Normally you name one script on the command line. If you name more, all are analyzed and included in the output. However, the first script named supplies the name for the spec file and for the executable folder or file. Its code is the first to execute at run-time.

For certain uses you may edit the contents of myscript.spec (described under Using Spec Files). After you do this, you name the spec file to PyInstaller instead of the script:

pyinstaller myscript.spec
The myscript.spec file contains most of the information provided by the options that were specified when pyinstaller (or pyi-makespec) was run with the script file as the argument. You typically do not need to specify any options when running pyinstaller with the spec file. Only a few command-line options have an effect when building from a spec file.

You may give a path to the script or spec file, for example

pyinstaller options… ~/myproject/source/myscript.py
or, on Windows,

pyinstaller "C:\Documents and Settings\project\myscript.spec"
Options
General Options
-h, --help	show this help message and exit
-v, --version	Show program version info and exit.
--distpath DIR	Where to put the bundled app (default: ./dist)
--workpath WORKPATH
 	Where to put all the temporary work files, .log, .pyz and etc. (default: ./build)
-y, --noconfirm
 	Replace output directory (default: SPECPATH/dist/SPECNAME) without asking for confirmation
--upx-dir UPX_DIR
 	Path to UPX utility (default: search the execution path)
-a, --ascii	Do not include unicode encoding support (default: included if available)
--clean	Clean PyInstaller cache and remove temporary files before building.
--log-level LEVEL
 	Amount of detail in build-time console messages. LEVEL may be one of TRACE, DEBUG, INFO, WARN, ERROR, CRITICAL (default: INFO).
What to generate
-D, --onedir	Create a one-folder bundle containing an executable (default)
-F, --onefile	Create a one-file bundled executable.
--specpath DIR	Folder to store the generated spec file (default: current directory)
-n NAME, --name NAME
 	Name to assign to the bundled app and spec file (default: first script’s basename)
What to bundle, where to search
--add-data <SRC;DEST or SRC:DEST>
 	Additional non-binary files or folders to be added to the executable. The path separator is platform specific, os.pathsep (which is ; on Windows and : on most unix systems) is used. This option can be used multiple times.
--add-binary <SRC;DEST or SRC:DEST>
 	Additional binary files to be added to the executable. See the --add-data option for more details. This option can be used multiple times.
-p DIR, --paths DIR
 	A path to search for imports (like using PYTHONPATH). Multiple paths are allowed, separated by ‘:’, or use this option multiple times
--hidden-import MODULENAME, --hiddenimport MODULENAME
 	Name an import not visible in the code of the script(s). This option can be used multiple times.
--additional-hooks-dir HOOKSPATH
 	An additional path to search for hooks. This option can be used multiple times.
--runtime-hook RUNTIME_HOOKS
 	Path to a custom runtime hook file. A runtime hook is code that is bundled with the executable and is executed before any other code or module to set up special features of the runtime environment. This option can be used multiple times.
--exclude-module EXCLUDES
 	Optional module or package (the Python name, not the path name) that will be ignored (as though it was not found). This option can be used multiple times.
--key KEY	The key used to encrypt Python bytecode.
How to generate
-d <all,imports,bootloader,noarchive>, --debug <all,imports,bootloader,noarchive>
 	
Provide assistance with debugging a frozen application. This argument may be provided multiple times to select several of the following options.

all: All three of the following options.
imports: specify the -v option to the underlying Python interpreter, causing it to print a message each time a module is initialized, showing the place (filename or built-in module) from which it is loaded. See https://docs.python.org/3/using/cmdline.html#id4.
bootloader: tell the bootloader to issue progress messages while initializing and starting the bundled app. Used to diagnose problems with missing imports.
noarchive: instead of storing all frozen Python source files as an archive inside the resulting executable, store them as files in the resulting output directory.
-s, --strip	Apply a symbol-table strip to the executable and shared libs (not recommended for Windows)
--noupx	Do not use UPX even if it is available (works differently between Windows and *nix)
--upx-exclude FILE
 	Prevent a binary from being compressed when using upx. This is typically used if upx corrupts certain binaries during compression. FILE is the filename of the binary without path. This option can be used multiple times.
Windows and Mac OS X specific options
-c, --console, --nowindowed
 	Open a console window for standard i/o (default). On Windows this option will have no effect if the first script is a ‘.pyw’ file.
-w, --windowed, --noconsole
 	Windows and Mac OS X: do not provide a console window for standard i/o. On Mac OS X this also triggers building an OS X .app bundle. On Windows this option will be set if the first script is a ‘.pyw’ file. This option is ignored in *NIX systems.
-i <FILE.ico or FILE.exe,ID or FILE.icns or “NONE”>, --icon <FILE.ico or FILE.exe,ID or FILE.icns or “NONE”>
 	FILE.ico: apply that icon to a Windows executable. FILE.exe,ID, extract the icon with ID from an exe. FILE.icns: apply the icon to the .app bundle on Mac OS X. Use “NONE” to not apply any icon, thereby making the OS to show some default (default: apply PyInstaller’s icon)
Windows specific options
--version-file FILE
 	add a version resource from FILE to the exe
-m <FILE or XML>, --manifest <FILE or XML>
 	add manifest FILE or XML to the exe
-r RESOURCE, --resource RESOURCE
 	Add or update a resource to a Windows executable. The RESOURCE is one to four items, FILE[,TYPE[,NAME[,LANGUAGE]]]. FILE can be a data file or an exe/dll. For data files, at least TYPE and NAME must be specified. LANGUAGE defaults to 0 or may be specified as wildcard * to update all resources of the given TYPE and NAME. For exe/dll files, all resources from FILE will be added/updated to the final executable if TYPE, NAME and LANGUAGE are omitted or specified as wildcard *.This option can be used multiple times.
--uac-admin	Using this option creates a Manifest which will request elevation upon application restart.
--uac-uiaccess	Using this option allows an elevated application to work with Remote Desktop.
Windows Side-by-side Assembly searching options (advanced)
--win-private-assemblies
 	Any Shared Assemblies bundled into the application will be changed into Private Assemblies. This means the exact versions of these assemblies will always be used, and any newer versions installed on user machines at the system level will be ignored.
--win-no-prefer-redirects
 	While searching for Shared or Private Assemblies to bundle into the application, PyInstaller will prefer not to follow policies that redirect to newer versions, and will try to bundle the exact versions of the assembly.
Mac OS X specific options
--osx-bundle-identifier BUNDLE_IDENTIFIER
 	Mac OS X .app bundle identifier is used as the default unique program name for code signing purposes. The usual form is a hierarchical name in reverse DNS notation. For example: com.mycompany.department.appname (default: first script’s basename)
Rarely used special options
--runtime-tmpdir PATH
 	Where to extract libraries and support files in onefile-mode. If this option is given, the bootloader will ignore any temp-folder location defined by the run-time OS. The _MEIxxxxxx-folder will be created here. Please use this option only if you know what you are doing.
--bootloader-ignore-signals
 	Tell the bootloader to ignore signals rather than forwarding them to the child process. Useful in situations where e.g. a supervisor process signals both the bootloader and child (e.g. via a process group) to avoid signalling the child twice.
Shortening the Command
Because of its numerous options, a full pyinstaller command can become very long. You will run the same command again and again as you develop your script. You can put the command in a shell script or batch file, using line continuations to make it readable. For example, in GNU/Linux:

pyinstaller --noconfirm --log-level=WARN \
    --onefile --nowindow \
    --add-data="README:." \
    --add-data="image1.png:img" \
    --add-binary="libfoo.so:lib" \
    --hidden-import=secret1 \
    --hidden-import=secret2 \
    --upx-dir=/usr/local/share/ \
    myscript.spec
Or in Windows, use the little-known BAT file line continuation:

pyinstaller --noconfirm --log-level=WARN ^
    --onefile --nowindow ^
    --add-data="README;." ^
    --add-data="image1.png;img" ^
    --add-binary="libfoo.so;lib" ^
    --hidden-import=secret1 ^
    --hidden-import=secret2 ^
    --icon=..\MLNMFLCN.ICO ^
    myscript.spec
Running PyInstaller from Python code
If you want to run PyInstaller from Python code, you can use the run function defined in PyInstaller.__main__. For instance, the following code:

import PyInstaller.__main__

PyInstaller.__main__.run([
    'my_script.py',
    '--onefile',
    '--windowed'
])
Is equivalent to:

pyinstaller my_script.py --onefile --windowed
Running PyInstaller with Python optimizations
Note

When using this feature, you should be aware of how the Python bytecode optimization mechanism works. When using -O, __debug__ is set to False and assert statements are removed from the bytecode. The -OO flag additionally removes docstrings.

Using this feature affects not only your main script, but all modules included by PyInstaller. If your code (or any module imported by your script) relies on these features, your program may break or have unexpected behavior.

PyInstaller can be run with Python optimization flags (-O or -OO) by executing it as a Python module, rather than using the pyinstaller command:

# run with basic optimizations
python -O -m PyInstaller myscript.py

# also discard docstrings
python -OO -m PyInstaller myscript.py
Or, by explicitly setting the PYTHONOPTIMIZE environment variable to a non-zero value:

# Unix
PYTHONOPTIMIZE=1 pyinstaller myscript.py

# Windows
set PYTHONOPTIMIZE=1 && pyinstaller myscript.py
You can use any PyInstaller options that are otherwise available with the pyinstaller command. For example:

python -O -m PyInstaller --onefile myscript.py
Alternatively, you can also use the path to pyinstaller:

python -O /path/to/pyinstaller myscript.py
Using UPX
UPX is a free utility available for most operating systems. UPX compresses executable files and libraries, making them smaller, sometimes much smaller. UPX is available for most operating systems and can compress a large number of executable file formats. See the UPX home page for downloads, and for the list of supported executable formats.

A compressed executable program is wrapped in UPX startup code that dynamically decompresses the program when the program is launched. After it has been decompressed, the program runs normally. In the case of a PyInstaller one-file executable that has been UPX-compressed, the full execution sequence is:

The compressed program start up in the UPX decompressor code.
After decompression, the program executes the PyInstaller bootloader, which creates a temporary environment for Python.
The Python interpreter executes your script.
PyInstaller looks for UPX on the execution path or the path specified with the --upx-dir option. If UPX exists, PyInstaller applies it to the final executable, unless the --noupx option was given. UPX has been used with PyInstaller output often, usually with no problems.

Encrypting Python Bytecode
To encrypt the Python bytecode modules stored in the bundle, pass the --key=key-string argument on the command line.

For this to work, you need to run:

pip install pyinstaller[encryption]
The key-string is a string of 16 characters which is used to encrypt each file of Python byte-code before it is stored in the archive inside the executable file.

This feature uses the tinyaes module internally for the encryption.

Defining the Extraction Location
In rare cases, when you bundle to a single executable (see Bundling to One File and How the One-File Program Works), you may want to control the location of the temporary directory at compile time. This can be done using the --runtime-tmpdir option. If this option is given, the bootloader will ignore any temp-folder location defined by the run-time OS. Please use this option only if you know what you are doing.

Supporting Multiple Platforms
If you distribute your application for only one combination of OS and Python, just install PyInstaller like any other package and use it in your normal development setup.

Supporting Multiple Python Environments
When you need to bundle your application within one OS but for different versions of Python and support libraries – for example, a Python 3.6 version and a Python 3.7 version; or a supported version that uses Qt4 and a development version that uses Qt5 – we recommend you use venv. With venv you can maintain different combinations of Python and installed packages, and switch from one combination to another easily. These are called virtual environments or venvs in short.

Use venv to create as many different development environments as you need, each with its unique combination of Python and installed packages.
Install PyInstaller in each virtual environment.
Use PyInstaller to build your application in each virtual environment.
Note that when using venv, the path to the PyInstaller commands is:

Windows: ENV_ROOT\Scripts
Others: ENV_ROOT/bin
Under Windows, the pip-Win package makes it especially easy to set up different environments and switch between them. Under GNU/Linux and Mac OS, you switch environments at the command line.

See PEP 405 and the official Python Tutorial on Virtual Environments and Packages for more information about Python virtual environments.

Supporting Multiple Operating Systems
If you need to distribute your application for more than one OS, for example both Windows and Mac OS X, you must install PyInstaller on each platform and bundle your app separately on each.

You can do this from a single machine using virtualization. The free virtualBox or the paid VMWare and Parallels allow you to run another complete operating system as a “guest”. You set up a virtual machine for each “guest” OS. In it you install Python, the support packages your application needs, and PyInstaller.

A File Sync & Share system like NextCloud is useful with virtual machines. Install the synchronization client in each virtual machine, all linked to your synchronization account. Keep a single copy of your script(s) in a synchronized folder. Then on any virtual machine you can run PyInstaller thus:

cd ~/NextCloud/project_folder/src # GNU/Linux, Mac -- Windows similar
rm *.pyc # get rid of modules compiled by another Python
pyinstaller --workpath=path-to-local-temp-folder  \
            --distpath=path-to-local-dist-folder  \
            ...other options as required...       \
            ./myscript.py
PyInstaller reads scripts from the common synchronized folder, but writes its work files and the bundled app in folders that are local to the virtual machine.

If you share the same home directory on multiple platforms, for example GNU/Linux and OS X, you will need to set the PYINSTALLER_CONFIG_DIR environment variable to different values on each platform otherwise PyInstaller may cache files for one platform and use them on the other platform, as by default it uses a subdirectory of your home directory as its cache location.

It is said to be possible to cross-develop for Windows under GNU/Linux using the free Wine environment. Further details are needed, see How to Contribute.

Capturing Windows Version Data
A Windows app may require a Version resource file. A Version resource contains a group of data structures, some containing binary integers and some containing strings, that describe the properties of the executable. For details see the Microsoft Version Information Structures page.

Version resources are complex and some elements are optional, others required. When you view the version tab of a Properties dialog, there’s no simple relationship between the data displayed and the structure of the resource. For this reason PyInstaller includes the pyi-grab_version command. It is invoked with the full path name of any Windows executable that has a Version resource:

pyi-grab_version executable_with_version_resource
The command writes text that represents a Version resource in readable form to standard output. You can copy it from the console window or redirect it to a file. Then you can edit the version information to adapt it to your program. Using pyi-grab_version you can find an executable that displays the kind of information you want, copy its resource data, and modify it to suit your package.

The version text file is encoded UTF-8 and may contain non-ASCII characters. (Unicode characters are allowed in Version resource string fields.) Be sure to edit and save the text file in UTF-8 unless you are certain it contains only ASCII string values.

Your edited version text file can be given with the --version-file= option to pyinstaller or pyi-makespec. The text data is converted to a Version resource and installed in the bundled app.

In a Version resource there are two 64-bit binary values, FileVersion and ProductVersion. In the version text file these are given as four-element tuples, for example:

filevers=(2, 0, 4, 0),
prodvers=(2, 0, 4, 0),
The elements of each tuple represent 16-bit values from most-significant to least-significant. For example the value (2, 0, 4, 0) resolves to 0002000000040000 in hex.

You can also install a Version resource from a text file after the bundled app has been created, using the pyi-set_version command:

pyi-set_version version_text_file executable_file
The pyi-set_version utility reads a version text file as written by pyi-grab_version, converts it to a Version resource, and installs that resource in the executable_file specified.

For advanced uses, examine a version text file as written by pyi-grab_version. You find it is Python code that creates a VSVersionInfo object. The class definition for VSVersionInfo is found in utils/win32/versioninfo.py in the PyInstaller distribution folder. You can write a program that imports versioninfo. In that program you can eval the contents of a version info text file to produce a VSVersionInfo object. You can use the .toRaw() method of that object to produce a Version resource in binary form. Or you can apply the unicode() function to the object to reproduce the version text file.

Building Mac OS X App Bundles
Under Mac OS X, PyInstaller always builds a UNIX executable in dist. If you specify --onedir, the output is a folder named myscript containing supporting files and an executable named myscript. If you specify --onefile, the output is a single UNIX executable named myscript. Either executable can be started from a Terminal command line. Standard input and output work as normal through that Terminal window.

If you specify --windowed with either option, the dist folder also contains an OS X application named myscript.app.

As you probably know, an application is a special type of folder. The one built by PyInstaller contains a folder always named Contents which contains:

A folder Frameworks which is empty.
A folder Resources that contains an icon file.
A file Info.plist that describes the app.
A folder MacOS that contains the the executable and supporting files, just as in the --onedir folder.
Use the icon= argument to specify a custom icon for the application. It will be copied into the Resources folder. (If you do not specify an icon file, PyInstaller supplies a file icon-windowed.icns with the PyInstaller logo.)

Use the osx-bundle-identifier= argument to add a bundle identifier. This becomes the CFBundleIdentifier used in code-signing (see the PyInstaller code signing recipe and for more detail, the Apple code signing overview technical note).

You can add other items to the Info.plist by editing the spec file; see Spec File Options for a Mac OS X Bundle below.

Platform-specific Notes
GNU/Linux
Making GNU/Linux Apps Forward-Compatible
Under GNU/Linux, PyInstaller does not bundle libc (the C standard library, usually glibc, the Gnu version) with the app. Instead, the app expects to link dynamically to the libc from the local OS where it runs. The interface between any app and libc is forward compatible to newer releases, but it is not backward compatible to older releases.

For this reason, if you bundle your app on the current version of GNU/Linux, it may fail to execute (typically with a runtime dynamic link error) if it is executed on an older version of GNU/Linux.

The solution is to always build your app on the oldest version of GNU/Linux you mean to support. It should continue to work with the libc found on newer versions.

The GNU/Linux standard libraries such as glibc are distributed in 64-bit and 32-bit versions, and these are not compatible. As a result you cannot bundle your app on a 32-bit system and run it on a 64-bit installation, nor vice-versa. You must make a unique version of the app for each word-length supported.

Windows
For Python >= 3.5 targeting Windows < 10, the developer needs to take special care to include the Visual C++ run-time .dlls: Python 3.5 uses Visual Studio 2015 run-time, which has been renamed into “Universal CRT“ and has become part of Windows 10. For Windows Vista through Windows 8.1 there are Windows Update packages, which may or may not be installed in the target-system. So you have the following options:

Build on Windows 7 which has been reported to work.

Include one of the VCRedist packages (the redistributable package files) into your application’s installer. This is Microsoft’s recommended way, see “Distributing Software that uses the Universal CRT“ in the above-mentioned link, numbers 2 and 3.

Install the Windows Software Development Kit (SDK) for Windows 10 and expand the .spec-file to include the required DLLs, see “Distributing Software that uses the Universal CRT“ in the above-mentioned link, number 6.

If you think, PyInstaller should do this by itself, please help improving PyInstaller.

Mac OS X
Making Mac OS X apps Forward-Compatible
In Mac OS X, components from one version of the OS are usually compatible with later versions, but they may not work with earlier versions.

The only way to be certain your app supports an older version of Mac OS X is to run PyInstaller in the oldest version of the OS you need to support.

For example, to be sure of compatibility with “Snow Leopard” (10.6) and later versions, you should execute PyInstaller in that environment. You would create a copy of Mac OS X 10.6, typically in a virtual machine. In it, install the desired level of Python (the default Python in Snow Leopard was 2.6, which PyInstaller no longer supports), and install PyInstaller, your source, and all its dependencies. Then build your app in that environment. It should be compatible with later versions of Mac OS X.

Building 32-bit Apps in Mac OS X
Note

This section still refers to Python 2.7 provided by Apple. It might not be valid for Python 3 installed from MacPorts or Homebrew.

Please contribute to keep this section up-to-date.

Older versions of Mac OS X supported both 32-bit and 64-bit executables. PyInstaller builds an app using the the word-length of the Python used to execute it. That will typically be a 64-bit version of Python, resulting in a 64-bit executable. To create a 32-bit executable, run PyInstaller under a 32-bit Python.

Python as installed in OS X will usually be executable in either 64- or 32-bit mode. To verify this, apply the file command to the Python executable:

$ file /usr/local/bin/python3
/usr/local/bin/python3: Mach-O universal binary with 2 architectures
/usr/local/bin/python3 (for architecture i386):     Mach-O executable i386
/usr/local/bin/python3 (for architecture x86_64):   Mach-O 64-bit executable x86_64
The OS chooses which architecture to run, and typically defaults to 64-bit. You can force the use of either architecture by name using the arch command:

$ /usr/local/bin/python3
Python 3.4.2 (v3.4.2:ab2c023a9432, Oct  5 2014, 20:42:22)
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import sys; sys.maxsize
9223372036854775807

$ arch -i386 /usr/local/bin/python3
Python 3.4.2 (v3.4.2:ab2c023a9432, Oct  5 2014, 20:42:22)
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import sys; sys.maxsize
2147483647
Apple’s default /usr/bin/python may circumvent the arch specification and run 64-bit regardless. (That is not the case if you apply arch to a specific version such as /usr/bin/python2.7.) To make sure of running 32-bit in all cases, set the following environment variable:

VERSIONER_PYTHON_PREFER_32_BIT=yes
arch -i386 /usr/bin/python pyinstaller --clean -F -w myscript.py
Getting the Opened Document Names
Note

Support for OpenDocument events is broken in PyInstaller 3.0 owing to code changes needed in the bootloader to support current versions of Mac OS X. Do not attempt to use this feature until it has been fixed. If this feature is important to you, follow and comment on the status of PyInstaller Issue #1309.

When a user double-clicks a document of a type your application supports, or when a user drags a document icon and drops it on your application’s icon, Mac OS X launches your application and provides the name(s) of the opened document(s) in the form of an OpenDocument AppleEvent. This AppleEvent is received by the bootloader before your code has started executing.

The bootloader gets the names of opened documents from the OpenDocument event and encodes them into the argv string before starting your code. Thus your code can query sys.argv to get the names of documents that should be opened at startup.

OpenDocument is the only AppleEvent the bootloader handles. If you want to handle other events, or events that are delivered after the program has launched, you must set up the appropriate handlers.

AIX
Depending on whether Python was build as a 32-bit or a 64-bit executable you may need to set or unset the environment variable OBJECT_MODE. To determine the size the following command can be used:

$ python -c "import sys; print(sys.maxsize) <= 2**32"
True
When the answer is True (as above) Python was build as a 32-bit executable.

When working with a 32-bit Python executable proceed as follows:

$ unset OBJECT_MODE
$ pyinstaller <your arguments>
When working with a 64-bit Python executable proceed as follows:

$ export OBJECT_MODE=64
$ pyinstaller <your arguments>